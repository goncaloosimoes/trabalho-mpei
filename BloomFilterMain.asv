clear;
clc;

FILENAME = 'data_table.csv';

[SIZE, HASHCOUNT] = calcularParametros('data_table.csv', 0.01);
SIZE = round(SIZE); % Passar de notação científica para int

% Verificar se o Bloom Filter já existe e carregar, se possível
if exist('bloomFilter.mat', 'file') == 2
    % Carregar o filtro Bloom existente
    load('bloomFilter.mat', 'bloomFilter');
    fprintf('Filtro Bloom carregado com sucesso.\n');
    
    % Carregar as transações conhecidas
    if exist('knownTransactions.mat', 'file') == 2
        load('knownTransactions.mat', 'knownTransactions');
        fprintf('Transações conhecidas carregadas com sucesso.\n');
    else
        knownTransactions = {};  % Se não existir, inicializa vazio
    end
    
    data = readtable(FILENAME);
    n = height(data);  % Número de linhas no ficheiro para calcular FPR
else
    % Criar o Bloom Filter
    bloomFilter = InitializeBF(SIZE);

    % Carregar Dados
    data = readtable(FILENAME);
    n = height(data); % número de linhas no ficheiro para calcular FPR

    % Verificar integridade dos dados
    requiredFields = {'age', 'gender'};
    if ~all(ismember(requiredFields, data.Properties.VariableNames))
        error('As colunas necessárias estão ausentes no arquivo CSV.');
    end

    % Remover linhas com dados ausentes
    data = rmmissing(data);

    % Adicionar dados ao Bloom Filter
    disp('Adicionando transações conhecidas ao Bloom Filter...');
    
    % Preparar set para guardar algumas transações conhecidas pelo filtro
    knownTransactions = {};  % Inicializa vazio

    tic; % Início do cronômetro
    for i = 1:height(data)
        ageStr = toString(data.age{i});
        genderStr = toString(data.gender{i});

        % Incluir indicador se é fraude ou não
        if data.fraud(i) == true
            fraudIndicator = "IF"; % indicador de fraude
        else
            fraudIndicator = "NF"; % não é fraude
        end

        % Construir o ID com base nos dados obtidos
        transactionID = sprintf('%s%s%d%s', ageStr, genderStr, i, fraudIndicator);
        transactionID = erase(transactionID, "'"); % retirar aspas do ID

        % adicionar ID da transação ao filtro
        bloomFilter = addBF(bloomFilter, transactionID, HASHCOUNT);

        if mod(i,10000) == 0
            % Mensagem de atualização
            fprintf('Adicionadas %d transações ao Bloom Filter...\n', i);
        end

        if mod(i, 100000) == 0
            % Adiciona transações específicas ao conjunto conhecido
            knownTransactions{end+1} = transactionID; %#ok<AGROW>
        end
    end
    toc; % Fim do cronômetro

    disp('Adição completa.');

    % Salvar o Bloom Filter e as transações conhecidas
    save('bloomFilter.mat', 'bloomFilter');
    save('knownTransactions.mat', 'knownTransactions');
    fprintf('Transações conhecidas salvas no arquivo.\n');
end

% Criar o array newTransactions com valores conhecidos e desconhecidos
disp('Preparando transações para teste...');

% Criar 3 IDs que não foram adicionados ao Bloom Filter
unknownTransactions = {};
for i = 1:3
    randomAge = randi([0, 6]); % Idade aleatória
    randomGenderNum = randi([0, 1]); % Gênero aleatório (0 ou 1)
    
    randomGender = 'M'; % gênero default
    if randomGenderNum == 1
        randomGender = 'F';
    end

    randomFraud = randi([0, 1]); % Fraude aleatória (0 ou 1)
    fraudIndicator = "IF";
    if randomFraud == 0
        fraudIndicator = "NF";
    end

    randomIndex = randi([n*10, n*20]); % Índice aleatório fora do intervalo usado
    unknownTransactions{end+1} = sprintf('%d%s%d%s', randomAge, toString(randomGender), randomIndex, fraudIndicator); %#ok<AGROW>
end

% Combinar valores conhecidos e desconhecidos
newTransactions = [knownTransactions, unknownTransactions];

% Verificar se novas transações são conhecidas ou suspeitas
disp('Verificando novas transações:');
disp('Deve indicar 5 conhecidas e no máximo 3 desconhecidas...')

for i = 1:length(newTransactions)
    transactionID = newTransactions{i};
    isPresent = checkBF(bloomFilter, transactionID, HASHCOUNT);

    resultMsg = 'NÃO é conhecida';
    if isPresent
        resultMsg = 'PODE ser conhecida (ou falso positivo)';
    end
    fprintf('A transação "%s" %s.\n', transactionID, resultMsg);
end

% Entrada de ID pelo usuário (com loop até pressionar Enter sem nada)
% Entrada de ID pelo usuário (com loop até pressionar Enter sem nada)
while true
    userID = input('Insira um ID de transação para verificar (exemplo: 25M123IF), ou pressione Enter para sair: ', 's');
    
    % Se o usuário pressionar Enter sem digitar nada, sai do loop
    if isempty(userID)
        disp('Saindo...');
        break;
    end

    % Verificar se o ID existe diretamente no Bloom Filter
    isPresent = checkBF(bloomFilter, userID, HASHCOUNT);

    % Se o ID terminar com "IF" e não for encontrado no Bloom Filter, considera como fraude
    if endsWith(userID, 'IF') && ~isPresent
        fprintf('O ID "%s" é considerado fraude (não encontrado no Bloom Filter, mas termina com "IF").\n', userID);
    elseif isPresent
        fprintf('A transação "%s" pode ser conhecida (ou falso positivo).\n', userID);
    else
        % Caso não seja encontrado, verificar a similaridade com IDs conhecidos
        [isFraud, closestMatch] = verificarSemelhancaTransferencias(userID, knownTransactions);
        
        if isFraud
            fprintf('O ID "%s" é semelhante a um ID de fraude (ID mais próximo: %s).\n', userID, closestMatch);
        else
            fprintf('O ID "%s" não corresponde a nenhuma fraude conhecida.\n', userID);
        end
    end
end

% Calcular taxa de falsos positivos
FPR = falsePositiveRate(SIZE, HASHCOUNT, n);
disp("Taxa de falsos positivos no Bloom Filter: " + FPR);
